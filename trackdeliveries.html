<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track Delivery - FikaConnect</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #f8f9fa;
            --bg-dark: #121212;
            --text-light: #fff;
            --text-dark: #222;
            --primary: #28a745;
            --primary-dark: #1e7e34;
            --secondary: #6c757d;
            --card-light: #ffffff;
            --card-dark: #1e1e1e;
            --status-pending: #ffc107;
            --status-picked-up: #17a2b8;
            --status-in-transit: #007bff;
            --status-delivered: #28a745;
            --status-cancelled: #dc3545;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --border-radius: 12px;
        }

        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: var(--bg-light);
            color: var(--text-dark);
            transition: all 0.3s ease;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-light);
        }

        #map {
            height: 50vh;
            width: 100%;
            border-bottom-left-radius: var(--border-radius);
            border-bottom-right-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 1;
        }

        .container {
            flex-grow: 1;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--card-light);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .dark-mode .card {
            background: var(--card-dark);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .card h2 {
            margin-top: 0;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
        }

        .card h3 {
            margin-top: 0;
            font-size: 1.2rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .dark-mode .card h3 {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .delivery-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .detail-item {
            display: flex;
            flex-direction: column;
        }

        .detail-item strong {
            font-size: 0.9rem;
            color: var(--secondary);
        }

        .dark-mode .detail-item strong {
            color: #aaa;
        }

        .detail-item span {
            font-weight: 500;
        }

        .status {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            align-self: flex-start;
        }
        .status-Pending-Driver-Assignment { background-color: var(--status-pending); color: black; }
        .status-Picked-Up { background-color: var(--status-picked-up); }
        .status-In-Transit { background-color: var(--status-in-transit); }
        .status-Delivered { background-color: var(--status-delivered); }
        .status-Cancelled { background-color: var(--status-cancelled); }
        .status-Cancelled-by-Sender { background-color: var(--status-cancelled); }

        .adjustment-box {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            padding: 15px;
            margin-top: 20px;
            border-radius: var(--border-radius);
        }

        .dark-mode .adjustment-box {
            background: #4a402f;
            border-color: #6e6144;
            color: #fff;
        }

        .adjustment-box h3 {
            border: none;
            margin-bottom: 10px;
        }

        .adjustment-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-accept, .btn-reject, .btn-back {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, background-color 0.2s;
        }

        .btn-accept { background: var(--primary); color: white; }
        .btn-accept:hover { background: var(--primary-dark); transform: translateY(-2px); }

        .btn-reject { background: var(--status-cancelled); color: white; }
        .btn-reject:hover { background: #c82333; transform: translateY(-2px); }
        
        .btn-back { background: var(--secondary); color: white; }
        .btn-back:hover { background: #5a6268; transform: translateY(-2px); }

        .message-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-light);
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 1rem;
            text-align: center;
            min-width: 300px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        .dark-mode .message-modal {
            background: var(--card-dark);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .message-modal h4 { margin: 0; }
        .message-modal button {
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .card {
                padding: 15px;
            }
            .delivery-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

<div id="map"></div>

<div class="container">
    <div class="card" id="detailsCard">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0;"><i class="fas fa-box-open"></i> Delivery Details</h2>
            <div id="statusBadge" class="status">Loading...</div>
        </div>
        <div id="deliveryInfo" class="delivery-details">
            <!-- Delivery details will be rendered here -->
        </div>
        <div class="adjustment-box" id="adjustmentBox" style="display:none;">
            <h3>Driver Requested Price Adjustment</h3>
            <div id="adjustmentDetails"></div>
            <div class="adjustment-actions">
                <button class="btn-accept" onclick="acceptAdjustment()">Accept</button>
                <button class="btn-reject" onclick="rejectAdjustment()">Reject</button>
            </div>
        </div>
        <button class="btn-back" style="margin-top: 20px;" onclick="window.history.back()">Back to Bookings</button>
    </div>
</div>

<!-- Message Modal UI -->
<div id="messageModal" class="message-modal">
    <h4 id="messageText"></h4>
    <button onclick="closeModal()">OK</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getFirestore, doc, onSnapshot, updateDoc, collection, addDoc, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDq3uO76nnqqPgPaFfXpOTEnFSXRqXneWU",
        authDomain: "fika-connect-5f844.firebaseapp.com",
        projectId: "fika-connect-5f844",
        storageBucket: "fika-connect-5f844.appspot.com",
        messagingSenderId: "492360448361",
        appId: "1:492360448361:web:4ab28b2b9828371d4b2f4a",
        databaseURL: "https://fika-connect-5f844-default-rtdb.firebaseio.com"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const rtdb = getDatabase(app);
    const auth = getAuth(app);

    // Get the booking ID from the URL
    const urlParams = new URLSearchParams(window.location.search);
    const bookingId = urlParams.get("bookingId");

    // Check for theme
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark-mode');
    }

    if (!bookingId) {
        showMessage("Booking ID not found in URL. Please go back to your bookings.");
        // Redirect after a short delay
        setTimeout(() => window.history.back(), 3000);
    }

    const map = L.map('map').setView([0, 0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    let driverMarker = null;
    let pickupMarker, dropoffMarker;
    let assignedDriverId = null;
    let routePolyline = null; // New variable to store the polyline

    // Show a custom message modal instead of alert
    function showMessage(text) {
        const modal = document.getElementById('messageModal');
        const messageText = document.getElementById('messageText');
        messageText.textContent = text;
        modal.style.display = 'flex';
    }

    // Close the custom message modal
    window.closeModal = function() {
        document.getElementById('messageModal').style.display = 'none';
    }

    // Function to decode the polyline string from OSRM
    function decodePolyline(str, precision) {
        let index = 0,
            lat = 0,
            lng = 0,
            coordinates = [];
        let shift = 0,
            result = 0,
            byte = null,
            latitude_change = 0,
            longitude_change = 0;
        const factor = Math.pow(10, precision || 5);

        while (index < str.length) {
            byte = null;
            shift = 0;
            result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);

            latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

            shift = result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);

            longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

            lat += latitude_change;
            lng += longitude_change;

            coordinates.push([lat / factor, lng / factor]);
        }
        return coordinates;
    }

    // Function to fetch and draw the route from OSRM
    async function getRouteAndDrawLine(pickupCoords, dropoffCoords) {
        const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${pickupCoords.lng},${pickupCoords.lat};${dropoffCoords.lng},${dropoffCoords.lat}?geometries=polyline`;
        
        try {
            const response = await fetch(osrmUrl);
            const data = await response.json();

            if (data.code === 'Ok' && data.routes.length > 0) {
                // Decode the polyline string to get coordinates
                const encodedPolyline = data.routes[0].geometry;
                const routeCoordinates = decodePolyline(encodedPolyline, 5);

                // Reformat coordinates for Leaflet
                const leafletCoordinates = routeCoordinates.map(coord => [coord[0], coord[1]]);

                // Remove old polyline if it exists
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                
                // Add new polyline to the map
                routePolyline = L.polyline(leafletCoordinates, { color: 'blue', weight: 5 }).addTo(map);
            } else {
                console.error("OSRM route not found or error:", data.message);
                showMessage("Could not find a detailed route. A straight line will be shown instead.");
                // Fallback to straight line if API fails
                const latlngs = [[pickupCoords.lat, pickupCoords.lng], [dropoffCoords.lat, dropoffCoords.lng]];
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                routePolyline = L.polyline(latlngs, { color: 'blue', weight: 5 }).addTo(map);
            }
        } catch (error) {
            console.error("Error fetching OSRM route:", error);
            showMessage("An error occurred while fetching the route. A straight line will be shown instead.");
            // Fallback to straight line on error
            const latlngs = [[pickupCoords.lat, pickupCoords.lng], [dropoffCoords.lat, dropoffCoords.lng]];
            if (routePolyline) {
                map.removeLayer(routePolyline);
            }
            routePolyline = L.polyline(latlngs, { color: 'blue', weight: 5 }).addTo(map);
        }
    }

    // Listen to booking document
    const deliveryRef = doc(db, "deliveries", bookingId);
    onSnapshot(deliveryRef, (snap) => {
        if (!snap.exists()) {
            showMessage("Delivery not found.");
            setTimeout(() => window.history.back(), 3000);
            return;
        }

        const data = snap.data();
        assignedDriverId = data.assignedDriver || null;
        
        // Update status badge
        const statusBadge = document.getElementById("statusBadge");
        statusBadge.textContent = data.status;
        statusBadge.className = `status status-${data.status.replace(/\s+/g, '-')}`;

        // Update detailed delivery information
        const deliveryInfoDiv = document.getElementById("deliveryInfo");
        const pickupInfo = data.deliveryType === 'direct' ? data.pickup.address : data.pickup.name;
        const dropoffInfo = data.deliveryType === 'direct' ? data.dropoff.address : data.dropoff.name;

        deliveryInfoDiv.innerHTML = `
            <div class="detail-item"><strong>Booking ID:</strong> <span>${snap.id}</span></div>
            <div class="detail-item"><strong>Booking Date:</strong> <span>${data.createdAt ? new Date(data.createdAt.seconds * 1000).toLocaleString() : 'N/A'}</span></div>
            <div class="detail-item"><strong>Recipient:</strong> <span>${data.recipient.name || 'N/A'}</span></div>
            <div class="detail-item"><strong>Recipient Phone:</strong> <span>${data.recipient.phone || 'N/A'}</span></div>
            <div class="detail-item"><strong>Package Description:</strong> <span>${data.package.description || 'N/A'}</span></div>
            <div class="detail-item"><strong>Pickup Location:</strong> <span>${pickupInfo}</span></div>
            <div class="detail-item"><strong>Drop-off Location:</strong> <span>${dropoffInfo}</span></div>
            <div class="detail-item"><strong>Current Fare:</strong> <span>UGX ${data.fareDetails?.totalFare?.toLocaleString() || 'N/A'}</span></div>
        `;

        // Show adjustment request if present
        if (data.adjustedFareDetails && data.status === "Awaiting Sender Approval") {
            const adj = data.adjustedFareDetails;
            const box = document.getElementById("adjustmentBox");
            const adjustmentDetailsDiv = document.getElementById("adjustmentDetails");
            
            box.style.display = "block";
            adjustmentDetailsDiv.innerHTML = `
                <p><b>Old Fare:</b> UGX ${adj.oldFare?.toLocaleString()}</p>
                <p><b>New Fare:</b> UGX ${adj.newFare?.toLocaleString()}</p>
                <p><b>Reason:</b> ${adj.reason}</p>
            `;
        } else {
            document.getElementById("adjustmentBox").style.display = "none";
        }

        // Show pickup/dropoff markers and center map
        if (data.pickup?.lat && data.pickup?.lng && data.dropoff?.lat && data.dropoff?.lng) {
            if (!pickupMarker) {
                pickupMarker = L.marker([data.pickup.lat, data.pickup.lng]).addTo(map).bindPopup("Pickup Location");
            }
            if (!dropoffMarker) {
                dropoffMarker = L.marker([data.dropoff.lat, data.dropoff.lng]).addTo(map).bindPopup("Drop-off Location");
            }

            // Get a realistic route and draw the line
            getRouteAndDrawLine(data.pickup, data.dropoff);

            const bounds = L.latLngBounds(pickupMarker.getLatLng(), dropoffMarker.getLatLng());
            map.fitBounds(bounds, { padding: [50, 50] });
        }
    });

    // Live driver location updates from Realtime Database
    onValue(ref(rtdb, `deliveries/${bookingId}/driverLocation`), (snap) => {
        const loc = snap.val();
        if (!loc || !loc.lat || !loc.lng) return;

        if (!driverMarker) {
            // Use a custom car icon for the driver
            const carIcon = L.icon({
                iconUrl: 'https://cdn-icons-png.flaticon.com/512/854/854894.png',
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
            });
            driverMarker = L.marker([loc.lat, loc.lng], { icon: carIcon }).addTo(map).bindPopup("Driver Location");
        } else {
            driverMarker.setLatLng([loc.lat, loc.lng]);
        }
    });

    // Accept adjustment
    window.acceptAdjustment = async function() {
        const docRef = doc(db, "deliveries", bookingId);
        try {
            const snap = await getDoc(docRef);
            const data = snap.data();
            
            if (data.status !== "Awaiting Sender Approval") {
                showMessage("This booking is no longer awaiting approval.");
                return;
            }

            await updateDoc(docRef, {
                status: "Driver Assigned",
                fareDetails: { totalFare: data.adjustedFareDetails.newFare },
                adjustedFareDetails: {}
            });

            // Push notification to driver
            if (assignedDriverId) {
                await addDoc(collection(db, "notifications"), {
                    driverId: assignedDriverId,
                    title: "Price Adjustment Accepted",
                    message: `Sender accepted your price adjustment. New fare: UGX ${data.adjustedFareDetails.newFare.toLocaleString()}`,
                    timestamp: serverTimestamp(),
                    read: false
                });
            }

            showMessage("Price adjustment accepted.");
        } catch(error) {
            console.error("Error accepting adjustment:", error);
            showMessage("Failed to accept price adjustment. Please try again.");
        }
    };

    // Reject adjustment
    window.rejectAdjustment = async function() {
        const docRef = doc(db, "deliveries", bookingId);
        try {
            const snap = await getDoc(docRef);
            const data = snap.data();

            if (data.status !== "Awaiting Sender Approval") {
                showMessage("This booking is no longer awaiting approval.");
                return;
            }

            await updateDoc(docRef, {
                status: "Cancelled by Sender"
            });

            // Push notification to driver
            if (assignedDriverId) {
                await addDoc(collection(db, "notifications"), {
                    driverId: assignedDriverId,
                    title: "Price Adjustment Rejected",
                    message: `Sender rejected your price adjustment for booking ${bookingId}. Delivery cancelled.`,
                    timestamp: serverTimestamp(),
                    read: false
                });
            }

            showMessage("Price adjustment rejected. The delivery has been cancelled.");
        } catch(error) {
            console.error("Error rejecting adjustment:", error);
            showMessage("Failed to reject price adjustment. Please try again.");
        }
    };
</script>
</body>
</html>
